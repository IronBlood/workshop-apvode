import{c as b,_ as r}from"./index-BO1U6PcM.js";import{d as c,U as m,r as v,G as u,g as p,o as g,a as h,b as a,e as n,L as t,i as f,j as _}from"./vendor-CuhU66Da.js";const y="/workshop-bfocm/assets/BFoCM-von-neumann-computer-C3DFUaq3.svg",x="/workshop-bfocm/assets/BFoCM-von-neumann-computer-anatomy-CAf57Qs2.svg",w="/workshop-bfocm/assets/BFoCM-von-neumann-computer-loop-CpzOQyFq.svg",d=e=>(f("data-v-eabbe151"),e=e(),_(),e),C=t('<section data-auto-animate data-auto-animate-id="one" data-v-eabbe151><h3 data-v-eabbe151>Main Memory</h3><h4 data-v-eabbe151>(Random Access Memory)</h4><ul class="text-3xl" data-v-eabbe151><li class="fragment" data-v-eabbe151>Registers are inside processors, built with logic gates just like ALUs and other components.</li><li class="fragment" data-v-eabbe151>Registers are super fast, but can only be used to store a small number of data elements.</li><li class="fragment" data-v-eabbe151>Main memory is an array of bits, organized in <span class="mono italic" data-v-eabbe151>W</span> words of <span class="mono italic" data-v-eabbe151>N</span> bits each.</li><li class="fragment" data-v-eabbe151>Typically <span class="mono italic" data-v-eabbe151>W</span> is power of 2 (<span class="mono" data-v-eabbe151>W = 2<sup data-v-eabbe151>k</sup></span>), e.g. W = 8 (k = 3 address bits), N = 32 bits per word.</li><li class="fragment" data-v-eabbe151>Can read from and write to individual words.</li><li class="fragment" data-v-eabbe151>Many possible implementations.</li></ul></section><section data-auto-animate data-auto-animate-id="one" data-v-eabbe151><h3 data-v-eabbe151>Main Memory</h3><h4 data-v-eabbe151>(Random Access Memory)</h4><table class="text-3xl" data-v-eabbe151><tr data-v-eabbe151><th class="text-center" data-v-eabbe151>Addr.</th><th class="text-center" data-v-eabbe151>Value</th></tr><tr data-v-eabbe151><td class="mono" data-v-eabbe151>000</td><td class="mono" data-v-eabbe151>11001001 01010001 10001111 01110011</td></tr><tr data-v-eabbe151><td class="mono" data-v-eabbe151>001</td><td class="mono" data-v-eabbe151>01011000 01110001 10101101 11010001</td></tr><tr data-v-eabbe151><td class="mono" data-v-eabbe151>010</td><td class="mono text-center" data-v-eabbe151>...</td></tr><tr data-v-eabbe151><td class="mono" data-v-eabbe151>...</td><td class="mono text-center" data-v-eabbe151>...</td></tr><tr data-v-eabbe151><td class="mono" data-v-eabbe151>111</td><td class="mono" data-v-eabbe151>10000100 01001111 11100100 00001000</td></tr></table></section><section data-auto-animate data-auto-animate-id="two" data-v-eabbe151><h3 data-v-eabbe151>Registers vs Memory</h3><ul class="text-3xl" data-v-eabbe151><li class="fragment" data-v-eabbe151>Typically variables live in memory.</li><li class="fragment" data-v-eabbe151>Registers hold temporary values or values that we need to use repeatedly.</li><li class="fragment" data-v-eabbe151>ALU operations work on registers only.</li><li class="fragment" data-v-eabbe151>To operate with memory variables: <ul data-v-eabbe151><li data-v-eabbe151>Load them into a register.</li><li data-v-eabbe151>Compute on them.</li><li data-v-eabbe151>Store the results back to memory.</li></ul></li></ul></section>',3),M={"data-auto-animate":"","data-auto-animate-id":"two"},k=d(()=>a("h3",null,"Registers vs Memory",-1)),N={class:"flex justify-center items-center"},R=t('<div class="w-1/2" data-v-eabbe151><ul data-v-eabbe151><li class="mono" data-v-eabbe151>0x1000: n</li><li class="mono" data-v-eabbe151>0x1004: r</li><li class="mono" data-v-eabbe151>0x1008: x</li><li class="mono" data-v-eabbe151>0x100C: y</li></ul></div>',1),A={class:"w-1/2"},I={class:"fragment"},B={class:"fragment"},P={"data-auto-animate":"","data-auto-animate-id":"three"},j=d(()=>a("h3",null,"von Neumann Computer",-1)),U={class:"flex items-center"},S=t('<div data-v-eabbe151><ul class="text-3xl" data-v-eabbe151><li class="fragment" data-v-eabbe151>Also called stored-program computer</li><li class="fragment" data-v-eabbe151>Express program as a sequence of <span class="strong" data-v-eabbe151>coded instructions</span></li><li class="fragment" data-v-eabbe151>Memory holds both data and instructions</li><li class="fragment" data-v-eabbe151>CPU fetches, interprets, and executes successive instructions of the program</li></ul></div>',1),E=t('<section data-auto-animate data-auto-animate-id="three" data-v-eabbe151><h3 data-v-eabbe151>von Neumann Computer</h3><div class="flex flex-col items-center" data-v-eabbe151><img data-src="'+x+'" data-v-eabbe151><ul class="text-3xl" data-v-eabbe151><li class="fragment" data-v-eabbe151><span class="strong" data-v-eabbe151>Instructions</span> coded as binary data</li><li class="fragment" data-v-eabbe151><span class="strong" data-v-eabbe151>Program Counter</span>, or PC, a special register, stores the address of the instruction to be executed</li><li class="fragment" data-v-eabbe151>Decode the instruction, and generate control signals for datapath</li></ul></div></section><section data-auto-animate data-auto-animate-id="three" data-v-eabbe151><h3 data-v-eabbe151>von Neumann Computer</h3><div class="flex justify-center" data-v-eabbe151><img data-src="'+w+'" data-v-eabbe151></div><div class="text-3xl text-left" data-v-eabbe151><div class="fragment mt-6" data-v-eabbe151>Instructions are the fundamental unit of work.</div><div class="fragment mt-6" data-v-eabbe151>Each instruction specifies: <ul data-v-eabbe151><li data-v-eabbe151>an operation (also called <span class="strong" data-v-eabbe151>opcode</span>) to be performed,</li><li data-v-eabbe151>source and destination <span class="strong" data-v-eabbe151>operands</span>.</li></ul></div><div class="fragment mt-6" data-v-eabbe151>By default, the next PC is current PC + size of current instruction, unless the instruction says otherwise. <span class="fragment" data-v-eabbe151><span class="strong" data-v-eabbe151>guess?</span></span></div></div></section><section data-v-eabbe151><h3 data-v-eabbe151>Your Own Programmable Machine</h3><ul data-v-eabbe151><li class="fragment" data-v-eabbe151>Now you can design your own CPU with logic gates. <span class="fragment" data-v-eabbe151>Theoretically.</span></li><li class="fragment" data-v-eabbe151>And you can write programs to run on your own CPU. <span class="fragment" data-v-eabbe151>In Binary.</span></li><li class="fragment" data-v-eabbe151>However it&#39;s too tedious to write programs directly in binary.</li><li class="fragment" data-v-eabbe151>So assembly language was created, it looks like <code data-v-eabbe151>add x1, x2, x3</code> and then would be translated by the <span class="strong" data-v-eabbe151>assemblers</span> into binary code.</li></ul></section>',3),F=`int x, y;
y = x - 37;`,L=`R1 <- Mem[0x1008]
R1 <- R1 - 37`,T=c({__name:"von-neumann-architecture",setup(e){const i=m("open_common_modal"),s=v(null);function l(){i.open_common_modal(s.value.outerHTML)}return u(()=>{b()}),(D,O)=>{const o=p("highlightjs");return g(),h("section",null,[C,a("section",M,[k,a("div",N,[R,a("div",A,[a("div",I,[n(o,{language:"c",autodetect:!1,code:F})]),a("div",B,[n(o,{language:"plaintext",autodetect:!1,code:L})])])])]),a("section",P,[j,a("div",U,[S,a("div",{class:"fragment",onClick:l},[a("img",{ref_key:"vNCImg",ref:s,"data-src":y},null,512)])])]),E])}}}),q=r(T,[["__scopeId","data-v-eabbe151"]]);export{q as default};
